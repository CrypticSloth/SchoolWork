# Homework 4
## Erik Sorensen

### Control	4.2, 4.4.1, 4.4.2, 4.6.1, and 4.6.2

#### 4.2. Explain each of the "dont't cares in Figure 4.18"

The MemtoReg field is irrelevant when the RegWrite signal is 0: since the register is not being written, the value of the data on the register data write port is not used.

#### 4.4.1. Which instructions fail to operate correctly if the MemToReg wire is stuck at 0?

ld will fail to work since the MemtoReg needs to be 1.

#### 4.4.2. Which instructions fail to operate correctly if the ALUSrc wire is stuck at 0?

both ld and st will fail to work since ALUSrc must be 1 for these instructions to work.

#### 4.6.1. What additional logic blocks, if any, are needed to add I-type instructions to the CPU shown in Figure 4.21? Add any necessary logic blocks to Figure 4.21 and explain their purpose.

The I-type instructions replace the rs2 and funct7 bits with an immediate value that takes up bits 20:31. Everything else is the same between I-type instructions and R-type instructions. For example, say we were going to implement the addi instruction. Instead of a "Read Register 2", we would take the immediate value and take it to an ALU where we would add the immediate value to the register in rs1 from the "Read Register 1". Then we would increment the PC. Therefore, there are no additional logic blocks added to the Figure to implement other than the data just going immediately to an ALU to be added.

#### 4.6.2. List the values of the signals generated by the control unit for addi. Explain the reasoning for any "don't care" control signals.

????

### Performance	4.10.1, 4.10.2, and 4.10.3

#### 4.10.1. What is the speedup achieved by adding this improvement (in 4.10)?

performance = 1 / execution time

execution time = time * cost

???? what do these instruction mixes mean?

#### 4.10.2. Compare the change in performance to the change in cost.



#### 4.10.3. Given the cost/performance ratios you just calculated, describe a situation where it makes sense to add more registers and describe a situation where it doesn't make sense to add more registers.



### Pipelining	4.22.1, 4.22.2, 4.22.3, 4.22.4, and 4.25.1, 4.25.2

#### 4.22.1. Draw a pipeline diagram to show were the code above will stall.

#### 4.22.2. In general, is it possible to reduce the number of stalls/ NOPs resulting from this structural hazard by reordering code?

???? What is an NOP?
#### 4.22.3. Must this structural hazard be handled in hardware? We have seen that data hazards can be eliminated by adding NOPs to the code. Can you do the same with this structural hazard? If so, explain how. If not, explain why not.

#### 4.22.4. Approximately how many stalls would you expect this structural hazard to generate in a typical program? (Use the instruction mix from Exercise 4.8)

#### 4.25.1. Show a pipeline execution diagram for the first two iterations of this loop.

#### 4.25.2. Mark pipeline stages that do not perform useful work. How often while the pipeline is full do we have a cycle in which all five pipeline stages are doing useful work? (Begin with the cyucle during which the subi is in the IF stage. End with the cycle during which the bnez is in the IF stage.)
